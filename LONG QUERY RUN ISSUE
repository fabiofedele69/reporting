üß© 1Ô∏è‚É£ How Actimize Stores and Executes SQL Statements

In NICE Actimize (whether RCM, SAM, WLF, or CDD modules), custom or dynamic SQL queries ‚Äî like the one you saw (WITH PredicateOffences AS ...) ‚Äî are not hardcoded in the Java or .NET code.
Instead, they are stored in metadata configuration tables inside the schema.

Typical examples (depending on your module):

| Common Table                                            | Description                                                      |
| ------------------------------------------------------- | ---------------------------------------------------------------- |
| `AI_CM_DRILL_DOWN_QUERIES`                              | Stores SQL for case drilldowns (usually the kind you‚Äôre seeing). |
| `AI_CM_INCIDENT_QUERIES`                                | Stores queries for incident management or alert details.         |
| `AI_RCM_INC_QUERIES` or `LC_RCM_INC_DRILL_DOWN_QUERIES` | RCM (Risk Case Manager)‚Äìspecific.                                |
| `AI_CM_QUERIES`                                         | Holds general SQL templates used by UI widgets or dashboards.    |

Each usually has columns like:

QUERY_ID
QUERY_NAME
QUERY_TYPE
QUERY (CLOB)
MODULE
PARAMETERS

The CLOB column QUERY contains the actual SQL (your WITH ... block).
The GUI or backend logic (Java service) pulls that query dynamically at runtime and executes it.

üß† 2Ô∏è‚É£ How the GUI ‚ÄúInvokes‚Äù It

Here‚Äôs what happens under the hood when a user clicks something in the Actimize GUI (for example, an ‚ÄúAlert Details‚Äù drilldown):

1. The GUI (web application) calls a REST or SOAP service in the Actimize Application Server (Java layer).
2. That service uses the query name or ID configured for that screen.

  - For example, it might call:

    select * from LC_RCM_INC_DRILL_DOWN_QUERIES where QUERY_NAME = 'AlertPredicateOffences';

3. The application reads the SQL text from the QUERY CLOB column.
4. It replaces placeholders like ${ALERT_ID}, ${USER_ID}, or :param1 with runtime parameters.
5. It executes the resulting SQL on the Oracle database through JDBC (as the JDBC Thin Client module, which is exactly what you saw in the AWR report).

So ‚Äî the GUI event ‚Üí Java backend ‚Üí query name ‚Üí CLOB SQL ‚Üí executed via JDBC Thin Client path explains what you saw in AWR.

üß≠ 3Ô∏è‚É£ How to Map GUI ‚Üí SQL

Here‚Äôs how you can trace it:

Step 1 ‚Äì Identify the query name or ID
In AWR, your SQL had:
SELECT ... FROM LC_RCM_INC_DRILL_DOWN_QUERIES WHERE QUERY_NAME = :1
or similar at the top ‚Äî this tells you which metadata record was used.

If you can‚Äôt see it, look for a string like:
... FROM LC_RCM_INC_DRILL_DOWN_QUERIES WHERE QUERY_NAME = 'PredicateOffences'
That‚Äôs the key link between GUI and SQL.

Step 2 ‚Äì Query the configuration table
Run this in SQL Developer:

SELECT QUERY_ID,
       QUERY_NAME,
       MODULE,
       PARAMETERS,
       DBMS_LOB.SUBSTR(QUERY, 4000, 1) AS QUERY_SNIPPET
FROM   LC_RCM_INC_DRILL_DOWN_QUERIES
WHERE  QUERY_NAME LIKE '%PredicateOffences%';

That gives you the definition the GUI is using.

Step 3 ‚Äì Look up the GUI element

In the Actimize Model Designer or Web Admin ‚Üí Configuration ‚Üí Queries section,
find that same query name.
You‚Äôll see the configuration for:
The operation or drilldown name,
The module or screen (e.g., Case Manager Alert view),
The parameters (like ALERT_ID, ENTITY_ID),
The SQL body (the WITH clause you saw).
So the GUI screen is tied to that query by name.

Step 4 ‚Äì Trace the backend execution (optional deep dive)

If you have access to logs on the Actimize Application Server:
 - Search in the logs (e.g., actimize.log, application.log) for the query name:
    grep -i "PredicateOffences" actimize.log
 - You‚Äôll see entries like:
    Executing DrillDownQuery: PredicateOffences with parameters [ALERT_ID=12345]
That log line tells you exactly which GUI action fired the SQL.

üß© 4Ô∏è‚É£ Example of Full Trace

| Step | Layer                            | What happens                                                                        |
| ---- | -------------------------------- | ----------------------------------------------------------------------------------- |
| 1    | User clicks ‚ÄúAlert Offences‚Äù tab | GUI calls API endpoint `/rcm/alerts/drilldown`                                      |
| 2    | App server                       | Finds configured query name `PredicateOffences`                                     |
| 3    | Database                         | Loads SQL from `LC_RCM_INC_DRILL_DOWN_QUERIES.QUERY`                                |
| 4    | App server                       | Replaces `${ALERT_ID}` parameter                                                    |
| 5    | DB (AWR capture)                 | Runs query via JDBC Thin Client ‚Üí appears in AWR as `WITH PredicateOffences AS ...` |
| 6    | GUI                              | Renders the results in the Alert details screen                                     |

‚öôÔ∏è 5Ô∏è‚É£ How to Reverse-Engineer This Yourself

To map any GUI action to SQL:
In the GUI, perform the action (e.g., open an alert tab).
In the DB, check AWR or V$SQLAREA filtered by MODULE='JDBC Thin Client' and your schema (CFC5CM3C).
Look for the query name in the SQL text.
Query the metadata table (*_QUERIES) to see its CLOB definition.
Optionally, review the logs for the same query name.

‚úÖ TL;DR Summary
| Question                       | Answer                                                                                      |
| ------------------------------ | ------------------------------------------------------------------------------------------- |
| **Where is the SQL stored?**   | In Actimize configuration tables (`*_QUERIES`), column `QUERY` (CLOB).                      |
| **How is it executed?**        | GUI calls backend ‚Üí backend fetches SQL from table ‚Üí JDBC executes it.                      |
| **Why does it appear in AWR?** | Because it‚Äôs executed through JDBC Thin Client on Oracle.                                   |
| **How to link GUI to SQL?**    | Use `QUERY_NAME` from AWR ‚Üí find record in config table ‚Üí confirm parameters in GUI / logs. |

üß† Overview of What This SQL Does
This is a complex multi-CTE query built for a materialized view or report (likely an Actimize drilldown).

It defines four Common Table Expressions (CTEs):
1. PredicateOffences
2. Passports
3. REGION
4. OWN_ENT
Each one builds an intermediate aggregation, and they‚Äôre later combined (in the unseen part) into the final SELECT.

üîç What‚Äôs Happening Inside Each CTE

1Ô∏è‚É£ PredicateOffences
SELECT listagg(po.predicate_offence_id || ':' || po.description, ',') ...
FROM LC_SCMT.WORK_ITEM_MULT_VAL_ATTRIBUTES ATTRIB
LEFT JOIN LC_SCMT.md_predicate_offence po
  ON ATTRIB.ATTRIBUTE_VALUE = po.predicate_offence_id
WHERE ATTRIB.ATTRIBUTE_TYPE = 5119
GROUP BY ATTRIB.WORK_ITEM_ID

‚úÖ Purpose: Builds a comma-separated list (LISTAGG) of predicate offences for each work item.
‚ö†Ô∏è Issues:

- LISTAGG on a large dataset can be very CPU and memory heavy (especially without parallelism).
- No filtering by WORK_ITEM_ID before aggregation ‚Äî so it scans the entire table where ATTRIBUTE_TYPE = 5119.
- LEFT JOIN on an unfiltered column (ATTRIBUTE_VALUE) might not use an index.

üß© Optimization ideas:

- Ensure index exists on (ATTRIBUTE_TYPE, ATTRIBUTE_VALUE) in WORK_ITEM_MULT_VAL_ATTRIBUTES.
- If WORK_ITEM_ID has high cardinality, consider breaking into batches or aggregating incrementally (materialized sub-view).

2Ô∏è‚É£ Passports
SELECT listagg(ATTRIB.ATTRIBUTE_VALUE, ',') ...
FROM LC_SCMT.WORK_ITEM_MULT_VAL_ATTRIBUTES ATTRIB
WHERE ATTRIB.ATTRIBUTE_TYPE = 5998
GROUP BY ATTRIB.WORK_ITEM_ID

‚úÖ Purpose: Aggregates passport-type attributes by work item.
‚ö†Ô∏è Issues:
- Same structure and risk as above: full scan on the same large table, but different attribute type.
- This likely scans the same table twice ‚Äî Oracle will treat each CTE independently.

üß© Optimization ideas:
- Combine PredicateOffences and Passports into a single scan with conditional aggregation:
    SELECT work_item_id,
           listagg(CASE WHEN attribute_type=5119 THEN po.predicate_offence_id||':'||po.description END, ',') AS predicate_offences,
           listagg(CASE WHEN attribute_type=5998 THEN attribute_value END, ',') AS passports
    FROM ...
    GROUP BY work_item_id;

‚Üí Cuts I/O in half and avoids repeated full scans.

3Ô∏è‚É£ REGION
SELECT DISTINCT NVL(LR.MD_REL_LIST_ITEM.VALUE, ...) AS Region,
       a.alert_id AS work_item_id
FROM LC_RCM_INC.ALERTS a
INNER JOIN LC_SCMT.MD_REL_LIST_ITEMS LR ...
INNER JOIN LC_SCMT.BUSINESS_UNIT_DEPENDENCIES BU ...
INNER JOIN LC_SCMT.MD_REL_LIST_ITEMS LRMD ...

‚úÖ Purpose: Gets regional information for alerts.
‚ö†Ô∏è Issues:
- DISTINCT across multiple joins suggests duplication due to one-to-many relationships ‚Äî expensive sort/hash deduplication.
- Several INNER JOINs to large master tables, possibly without proper predicates.
- No filters on alerts (e.g., by status/date), which can inflate join size dramatically.

üß© Optimization ideas:

- Add selective predicates (e.g., WHERE a.alert_status = 'OPEN').
- Check indexes on join keys:
    - LC_RCM_INC.ALERTS.ALERT_ID
    - LC_SCMT.MD_REL_LIST_ITEMS.LIST_ITEM_ID
    - LC_SCMT.BUSINESS_UNIT_DEPENDENCIES.BU_ID
- If possible, pre-materialize region mapping into a smaller lookup view.

4Ô∏è‚É£ OWN_ENT
SELECT OE.ALERT_ID AS alert_id,
       LISTAGG( NVL(oe.business_div_code, '') || '|' || NVL(oe.business_division, '') || ... )
       WITHIN GROUP (ORDER BY oe.alert_id ASC) AS OWN_ENT
FROM LC_SCMT.MT_OWNING_UBS_ENTITIES OE
UNION SELECT 'Investment Bank' ... FROM DUAL
UNION SELECT 'Wealth Management' ... FROM DUAL
...

‚úÖ Purpose: Builds ownership hierarchy text by alert.
‚ö†Ô∏è Issues:
- LISTAGG again ‚Äî string aggregation on potentially large table.
- Multiple UNIONs against DUAL for static code mappings ‚Äî inefficient and unnecessary; should be replaced by a small lookup table or inline values clause:
    SELECT * FROM (VALUES ('Investment Bank','IB'), ('Wealth Management','WM')) ...
- UNION (default = DISTINCT) repeatedly sorts and deduplicates ‚Äî use UNION ALL if no duplicates.

üß© Optimization ideas:

Replace UNION with UNION ALL if duplicates aren‚Äôt an issue.
Move constant mappings into a joinable small table (1-time lookup).
Index ALERT_ID on MT_OWNING_UBS_ENTITIES.

üßÆ Performance Summary (Partial SQL)
| CTE                 | Likely Cost Driver    | Optimization Hint                                      |
| ------------------- | --------------------- | ------------------------------------------------------ |
| `PredicateOffences` | Full scan + LISTAGG   | Combine with `Passports`, index `ATTRIBUTE_TYPE`       |
| `Passports`         | Full scan + LISTAGG   | Same as above                                          |
| `REGION`            | Multi-join + DISTINCT | Add filters, verify join indexes                       |
| `OWN_ENT`           | LISTAGG + UNIONs      | Use `UNION ALL`, replace DUAL unions with lookup table |

‚öôÔ∏è General Observations
1. Multiple full scans of the same large table (WORK_ITEM_MULT_VAL_ATTRIBUTES) ‚Äî major CPU and I/O cost.
2. Repeated LISTAGG operations ‚Äî known CPU hotspot.
3. Unnecessary DISTINCT and UNION sorts ‚Äî sorting costs spike exponentially with data volume.
4. No selective predicates ‚Äî everything aggregates all data.
5. Possible join fan-out ‚Äî multiple joins may multiply rows before grouping.

‚úÖ Tuning Recommendations (Next Steps)

| Area             | Action                                                                                         |
| ---------------- | ---------------------------------------------------------------------------------------------- |
| **Data reuse**   | Materialize heavy CTEs into global temporary tables if reused multiple times.                  |
| **Reduce scans** | Combine CTEs on same table with CASE aggregation.                                              |
| **Aggregation**  | Consider using `XMLAGG` or analytic functions for string concatenation if `LISTAGG` overflows. |
| **Sorting**      | Use `UNION ALL` instead of `UNION` when possible.                                              |
| **Statistics**   | Ensure accurate stats on all large base tables, especially `WORK_ITEM_MULT_VAL_ATTRIBUTES`.    |
| **Parallelism**  | Enable `PARALLEL` hint or `ALTER MATERIALIZED VIEW ... PARALLEL` to exploit CPU cores.         |

********************************** FINAL CONCLUSION OVERALL SQL ****************************************************

1. Repeated full scans + LISTAGG on the same table

CTEs:
WITH PredicateOffences AS (
  SELECT listagg(... ) ... 
  FROM LC_SCMT.WORK_ITEM_MULT_VAL_ATTRIBUTES ATTRIB
  LEFT JOIN LC_SCMT.MD_PREDICATE_OFFENCE po
        ON ATTRIB.ATTRIBUTE_VALUE = po.predicate_offence_id
  WHERE ATTRIB.ATTRIBUTE_TYPE = 5119
  GROUP BY ATTRIB.WORK_ITEM_ID
),
Passports AS (
  SELECT listagg(ATTRIB.ATTRIBUTE_VALUE, ',') ...
  FROM LC_SCMT.WORK_ITEM_MULT_VAL_ATTRIBUTES ATTRIB
  WHERE ATTRIB.ATTRIBUTE_TYPE = 5998
  GROUP BY ATTRIB.WORK_ITEM_ID
),
...

Issues:
- Same table scanned multiple times (WORK_ITEM_MULT_VAL_ATTRIBUTES), once per CTE.
- LISTAGG is CPU-heavy; doing it twice over similar data doubles the cost.
- In the final query you only need rows for the selected alerts (a.alert_id), but these CTEs appear to aggregate all work items, then later you join:

    LEFT JOIN PredicateOffences PR ON PR.work_item_id = a.alert_id
    LEFT JOIN Passports        P  ON P.work_item_id  = a.alert_id

If the CTE is not fully ‚Äúmerged‚Äù by the optimizer, you‚Äôre computing aggregates for all rows, to then keep just a handful.

Tuning ideas:

Combine them into one scan with conditional aggregation:

WITH AggAttributes AS (
  SELECT work_item_id,
         listagg(CASE WHEN attribute_type = 5119
                      THEN po.predicate_offence_id || ':' || po.description
                 END, ',') AS predicate_offences,
         listagg(CASE WHEN attribute_type = 5998
                      THEN attribute_value
                 END, ',') AS passports
  FROM LC_SCMT.WORK_ITEM_MULT_VAL_ATTRIBUTES a
  LEFT JOIN LC_SCMT.MD_PREDICATE_OFFENCE po
         ON a.attribute_value = po.predicate_offence_id
  WHERE attribute_type IN (5119, 5998)
  GROUP BY work_item_id
)
...
LEFT JOIN AggAttributes agg ON agg.work_item_id = a.alert_id

- Make sure you have an index such as WORK_ITEM_MULT_VAL_ATTRIBUTES (WORK_ITEM_ID, ATTRIBUTE_TYPE, ATTRIBUTE_VALUE).
- If this query is usually run for a single alert (as suggested by WHERE a.alert_id = 'adv_20250410_00009' in your test), you can also rewrite as correlated aggregates:

SELECT (SELECT listagg(... )
        FROM WORK_ITEM_MULT_VAL_ATTRIBUTES ...
        WHERE work_item_id = a.alert_id AND attribute_type = 5119) AS predicateoffences,
       (SELECT listagg(... )
        FROM WORK_ITEM_MULT_VAL_ATTRIBUTES ...
        WHERE work_item_id = a.alert_id AND attribute_type = 5998) AS passports,
       ...
FROM LC_RCM_INC.ALERTS a
...

That lets the optimizer use work_item_id as a selective predicate instead of aggregating everything.

2. REGION CTE ‚Äì DISTINCT + multi-join

REGION AS (
  SELECT DISTINCT
         NVL(LR.MD_REL_LIST_ITEM_VALUE, ...) AS Region,
         a.alert_id AS work_item_id
  FROM LC_RCM_INC.ALERTS a
  JOIN LC_SCMT.MD_REL_LIST_ITEMS LR ...
  JOIN LC_SCMT.BUSINESS_UNIT_DEPENDENCIES BU ...
  JOIN LC_SCMT.MD_REL_LIST_ITEMS LRMD ...
)
...
LEFT JOIN REGION LR ON LR.work_item_id = a.alert_id

Issues:
- DISTINCT on a multi-join result usually means row-duplication somewhere ‚Üí expensive sort or hash dedupe.
- Again, if you run this for a small number of alerts, precomputing REGION for all alerts is wasted work.

Tuning ideas:
- If each alert logically has only one region, fix the join so it doesn‚Äôt duplicate rows and drop DISTINCT.
- Push the alert filter inside the CTE:

REGION AS (
  SELECT ...
  FROM ALERTS a
  ...
  WHERE a.alert_type_id = 3   -- and/or matching filters
)

- Or do this join directly in the main FROM clause instead of via a CTE, letting the optimizer pick the best join order.

Make sure there are indexes on the join keys used here (IDs in the MD_* and BUSINESS_UNIT_DEPENDENCIES tables).

3. OWN_ENT CTE ‚Äì LISTAGG + UNIONs from DUAL
In OWN_ENT AS you:
- Build a big LISTAGG over MT_OWNING_UBS_ENTITIES OE,
- Add a series of UNION queries selecting constant values from DUAL.
Issues:
- UNION (not UNION ALL) forces a sort/dedup each time‚Äîunnecessary if you know constants are unique.
- Using lots of SELECT ... FROM DUAL is clumsy and can hurt readability/perf.
Tuning ideas:
- Use UNION ALL unless you genuinely expect duplicates:
   
    UNION ALL SELECT 'Investment Bank' AS BUSINESS_DIVISION, 'IB' AS BUS_DIV_CODE, 1 RID FROM DUAL
    ...

- Better: put those static mappings into a tiny lookup table and JOIN it ‚Äî the optimizer can treat it much more efficiently.
- As with other CTEs, make sure MT_OWNING_UBS_ENTITIES has an index on ALERT_ID.

4. Correlated subquery to get latest audit record
In the FROM section:
INNER JOIN LC_RCM_INC.ACM_ALERT_CUSTOM_ATTRIBUTES ac
   ON ac.ALERT_CUSTOM_ATTRIBUTES_ID = a.alert_custom_attributes_id
INNER JOIN LC_RCM_INC.ACM_AUDITS aud
   ON aud.AUDIT_INTERNAL_ID = (
        SELECT aud.audit_internal_id
        FROM LC_RCM_INC.ACM_AUDITS aud
        JOIN LC_RCM_INC.ACM_ALERT_AUDITS alertaud
          ON alertaud.audit_internal_id = aud.audit_internal_id
        JOIN LC_RCM_INC.ALERTS alert
          ON alert.alert_internal_id = alertaud.alert_internal_id
        WHERE alert.alert_id = a.alert_id
          AND (aud.event LIKE '%created' OR aud.event LIKE '%updated')
        ORDER BY aud.create_date DESC
        FETCH FIRST 1 ROWS ONLY
      )

Issues:
- This is a scalar correlated subquery with join + sort. If the main query returns many alerts (e.g., in MV refresh), this pattern is very expensive (one subquery per alert).
- The ORDER BY ... FETCH FIRST 1 ROWS ONLY means a sort or Top-N per alert.

Tuning ideas:
- Precompute ‚Äúlatest audit per alert‚Äù in one pass, then join:

      WITH LatestAudit AS (
        SELECT alert.alert_id,
               aud.audit_internal_id,
               ROW_NUMBER() OVER (
                 PARTITION BY alert.alert_id
                 ORDER BY aud.create_date DESC
               ) AS rn
        FROM   LC_RCM_INC.ACM_AUDITS aud
        JOIN   LC_RCM_INC.ACM_ALERT_AUDITS alertaud
               ON alertaud.audit_internal_id = aud.audit_internal_id
        JOIN   LC_RCM_INC.ALERTS alert
               ON alert.alert_internal_id = alertaud.alert_internal_id
        WHERE  aud.event LIKE '%created'
            OR aud.event LIKE '%updated'
      )
      ...
      JOIN LatestAudit la
        ON la.alert_id = a.alert_id
       AND la.rn = 1

That replaces N scalar queries with a single analytic query.

5. Very wide SELECT list with many NVL/TO_CHAR
The middle of snippets 2 & 3 is a long list like:
SELECT NVL(a.p1, '')  AS "a.p1",
       NVL(a.p2, '')  AS "a.p2",
       ...
       NVL(TO_CHAR(ac.cd12,'yyyy/mm/dd HH24:mi:ss'),'') AS "ac.cd12",
       ...
This is mostly cosmetic / formatting and not the main performance problem, but:
- Repeated NVL(TO_CHAR(...)) on the same date columns is extra CPU.
- If the same expression is used several times, compute it once (subquery or CTE) and reuse.
Not a priority compared to the CTE and scalar-subquery issues, but something to be aware of.

6. Final WHERE and joins
Bottom of the query:
...
LEFT JOIN LC_SCMT.WORK_ITEM_ATTRIBUTES WIT ON WIT.WORK_ITEM_ID = a.alert_id
LEFT JOIN REGION LR             ON LR.work_item_id    = a.alert_id
LEFT JOIN PredicateOffences PR  ON PR.work_item_id    = a.alert_id
LEFT JOIN Passports P           ON P.work_item_id     = a.alert_id
LEFT JOIN OWN_ENT ON OWN_ENT.alert_id = a.alert_id
WHERE a.alert_type_id = 3
  AND a.alert_id      = :alert_id;

For a single-alert drilldown, this is fine if the optimizer can push the a.alert_id filter inside the CTEs. But because those CTEs aggregate over all rows without referencing a, Oracle may or may not fully push the predicate. 
That‚Äôs why I‚Äôd strongly prefer correlated aggregates or CTEs that explicitly join to ALERTS with a.alert_id inside them.

Overall verdict
Is the query ‚Äúgood‚Äù? Functionally yes; performance-wise it‚Äôs heavy and can be significantly improved.

Main inefficiencies:
1. Multiple CTEs scanning the same large table and doing LISTAGG aggregations independently.
2. CTEs that aggregate all rows, even when only a small subset of alerts is needed.
3. DISTINCT, UNION (rather than UNION ALL), and correlated scalar subqueries that force repeated sorts.
4. No explicit push of the alert filter into those CTEs.

Biggest wins if you refactor:

- Merge CTEs on the same base table and/or turn them into correlated aggregates that filter by a.alert_id.
- Replace the correlated ‚Äúlatest audit‚Äù subquery with a single analytic query (ROW_NUMBER).
- Remove unnecessary DISTINCT / UNION, or change to UNION ALL.
- Ensure proper indexing on:
    - WORK_ITEM_MULT_VAL_ATTRIBUTES (WORK_ITEM_ID, ATTRIBUTE_TYPE, ATTRIBUTE_VALUE)
    - MT_OWNING_UBS_ENTITIES (ALERT_ID)
    - All the foreign-key IDs used in joins (ALERTS, audit tables, MD_* tables).
