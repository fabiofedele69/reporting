1Ô∏è‚É£ Base View You Need

All queries use:

V$SESSION
V$SESSION_WAIT / V$SESSION_EVENT
V$EVENT_NAME

You need SELECT_CATALOG_ROLE or DBA.

2Ô∏è‚É£ Active Sessions (ON CPU)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.status,
    s.sql_id,
    s.program,
    s.machine
FROM v$session s
WHERE s.status = 'ACTIVE'
  AND s.state = 'ON CPU';

Meaning
- Session is executing SQL
- Using CPU
- Counts as Active Session

3Ô∏è‚É£ Waiting ‚Äì NON-IDLE (Active Wait)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.event,
    s.wait_class,
    s.seconds_in_wait
FROM v$session s
WHERE s.status = 'ACTIVE'
  AND s.state = 'WAITING'
  AND s.wait_class <> 'Idle';

Meaning
- Session is blocked on DB resource
- Still counts as Active Session

4Ô∏è‚É£ Waiting ‚Äì IDLE (Not Active)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.event,
    s.wait_class,
    s.seconds_in_wait
FROM v$session s
WHERE s.state = 'WAITING'
  AND s.wait_class = 'Idle';

Meaning
- Connected, doing nothing
- Does NOT count as active workload

5Ô∏è‚É£ Combined View (Most Useful)
This gives you everything in one query with clear classification:

SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.state,
    s.wait_class,
    s.event,
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END AS session_type
FROM v$session s
WHERE s.type = 'USER'
ORDER BY session_type, s.sid;

6Ô∏è‚É£ Aggregated View (Perfect for Graphs)
This query is ideal if you want counts per category:

SELECT
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END AS session_type,
    COUNT(*) AS session_count
FROM v$session s
WHERE s.type = 'USER'
GROUP BY
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END;

7Ô∏è‚É£ Historical Version (ASH ‚Äì Last 10 Minutes)
If you want historical SQL_IDs (not just current):

SELECT
    sql_id,
    session_state,
    wait_class,
    COUNT(*) samples
FROM v$active_session_history
WHERE sample_time > SYSDATE - (10/1440)
GROUP BY sql_id, session_state, wait_class
ORDER BY samples DESC;

Interpretation
- SESSION_STATE = 'ON CPU'
- SESSION_STATE = 'WAITING'
- WAIT_CLASS = 'Idle' ‚Üí idle

8Ô∏è‚É£ Blocking Sessions (Bonus)
SELECT
    s.sid,
    s.serial#,
    s.sql_id,
    s.blocking_session,
    s.event,
    s.wait_class
FROM v$session s
WHERE s.blocking_session IS NOT NULL;

9Ô∏è‚É£ DBA Golden Rule (Remember This)
Performance analysis = ON CPU + WAIT NON-IDLE
WAIT IDLE = ignore for tuning

How to Get the SQL Statement from a SQL_ID (Oracle 19c)
From Memory (Best / Real-Time)
Use V$SQL (SQL still in shared pool)

SELECT
    sql_id,
    child_number,
    sql_text
FROM v$sql
WHERE sql_id = '<SQL_ID>';

Notes
- Returns current SQL text
- Multiple rows = multiple child cursors
- Fastest and most accurate
‚ö†Ô∏è If no rows ‚Üí SQL aged out of memory

Full SQL Text (Long Statements)
V$SQL.SQL_TEXT is truncated.
To get the complete SQL:

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_fulltext, 4000, 1) AS sql_text
FROM v$sql
WHERE sql_id = '<SQL_ID>';

For >4000 chars, extract in chunks.

From Active Sessions (If Still Running)
SELECT
    s.sid,
    s.serial#,
    s.sql_id,
    q.sql_text
FROM v$session s
JOIN v$sql q ON s.sql_id = q.sql_id
WHERE s.sql_id = '<SQL_ID>';

From AWR (Historical ‚Äì Most Reliable)
Use DBA_HIST_SQLTEXT

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_text, 4000, 1) AS sql_text
FROM dba_hist_sqltext
WHERE sql_id = '<SQL_ID>';

Notes
- Requires Diagnostics Pack
- SQL must have appeared in AWR snapshot
- Works even if SQL aged out of memory

From ASH (Correlating to Execution Time)
SELECT DISTINCT
    ash.sql_id,
    DBMS_LOB.SUBSTR(txt.sql_text, 4000, 1) AS sql_text
FROM v$active_session_history ash
JOIN dba_hist_sqltext txt ON ash.sql_id = txt.sql_id
WHERE ash.sql_id = '<SQL_ID>';

Using TOAD (GUI Way ‚Äì Quick)
If you are in TOAD:
Paste SQL_ID
Open:
Database ‚Üí Monitor ‚Üí Sessions
Right-click session ‚Üí View SQL
Or:
Database ‚Üí Diagnose ‚Üí AWR ‚Üí Top SQL
‚Üí Double-click SQL_ID
TOAD internally queries V$SQL or DBA_HIST_SQLTEXT.

Edge Cases You Should Know
SQL_ID Exists but No SQL Text

Possible reasons:
SQL aged out of shared pool
SQL not captured in AWR
Privilege issue
Multiple SQL Texts for Same SQL_ID?

‚ùå Impossible
SQL_ID is a hash of SQL text.

One-Query ‚ÄúTry Everything‚Äù (Recommended)
SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_fulltext, 4000, 1) AS sql_text,
    'V$SQL' AS source
FROM v$sql
WHERE sql_id = '<SQL_ID>'

UNION ALL

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_text, 4000, 1),
    'AWR'
FROM dba_hist_sqltext
WHERE sql_id = '<SQL_ID>';

DBA Rule to Remember
If the SQL is still running ‚Üí V$SQL
If it ran in the past ‚Üí AWR


*********************************************************

Below are production-safe SQL queries you can run on Oracle 19c to get session counts per owner (schema/user) split by:

ON CPU
WAIT (non-idle) ‚Üí active wait
WAIT (idle)

Core Dashboard Query (Per Owner / Per State)

SELECT
    NVL(s.username, 'BACKGROUND') AS owner,
    SUM(CASE
            WHEN s.state = 'ON CPU'
            THEN 1
            ELSE 0
        END) AS on_cpu,
    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
            THEN 1
            ELSE 0
        END) AS wait_non_idle,
    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class = 'Idle'
            THEN 1
            ELSE 0
        END) AS wait_idle,
    COUNT(*) AS total_sessions
FROM v$session s
WHERE s.type = 'USER'
GROUP BY s.username
ORDER BY total_sessions DESC;

For each owner (schema / user) you get:

Column	         Meaning
ON_CPU	         Sessions actively consuming CPU
WAIT_NON_IDLE	 Sessions blocked by DB resources
WAIT_IDLE	     Sessions idle / client wait
TOTAL_SESSIONS	 All user sessions

‚úÖ Uses Oracle‚Äôs exact session state logic
‚úÖ Matches AWR / ASH definitions
‚úÖ Ideal for TOAD grids or charts

Example Interpretation
OWNER	     ON_CPU	WAIT_NON_IDLE	WAIT_IDLE
APP_USER	 12	          8               150
BATCH	      5	         30                 0
REPORT	      1	          0                40


Variant: Only ‚ÄúActive Sessions‚Äù (Ignore Idle Completely)
If you want only performance-relevant sessions:

SELECT
    s.username AS owner,
    SUM(CASE
            WHEN s.state = 'ON CPU' THEN 1
            ELSE 0
        END) AS on_cpu,
    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
            THEN 1
            ELSE 0
        END) AS wait_non_idle,
    COUNT(*) AS active_sessions
FROM v$session s
WHERE s.type = 'USER'
  AND ( s.state = 'ON CPU'
     OR (s.state = 'WAITING' AND s.wait_class <> 'Idle') )
GROUP BY s.username
ORDER BY active_sessions DESC;

üëâ This aligns with Average Active Sessions (AAS) logic.

‚è± Time-Series Version (For Graphing)
If you want historical counts by owner (ASH, last 15 minutes):

SELECT
    ash.username AS owner,
    ash.session_state,
    ash.wait_class,
    COUNT(*) AS samples
FROM v$active_session_history ash
WHERE ash.sample_time > SYSDATE - (15/1440)
GROUP BY ash.username, ash.session_state, ash.wait_class
ORDER BY samples DESC;

Interpretation
Each sample ‚âà 1 second
Samples ‚âà session-seconds

üìå Important Notes (Read This)
‚úî Correctness

Idle sessions are separated (not counted as active)
Non-idle waits are true performance waits
ON CPU + WAIT_NON_IDLE = real load

‚ö† Common Pitfalls

Do not sum idle sessions when sizing CPU
High WAIT_IDLE = connection pooling issue, not DB issue
High WAIT_NON_IDLE = tuning / contention issue


*******************************************************

What You Can Build (Correct Historical Dashboard)

You can build a historical dashboard per owner for:

ON CPU
WAIT non-idle
(using ASH)

And combine it with:
Current WAIT idle (from V$SESSION)
This is how DBAs do it in real life.

‚úÖ Historical Dashboard (ASH ‚Äì Past Sessions)

This gives you per owner, per state, over a time window.
üîπ Last 30 Minutes ‚Äì Per Owner

SELECT
    NVL(username, 'UNKNOWN') AS owner,
    SUM(CASE
            WHEN session_state = 'ON CPU'
            THEN 1
            ELSE 0
        END) AS on_cpu_samples,
    SUM(CASE
            WHEN session_state = 'WAITING'
             AND wait_class <> 'Idle'
            THEN 1
            ELSE 0
        END) AS wait_non_idle_samples,
    COUNT(*) AS total_active_samples
FROM v$active_session_history
WHERE sample_time > SYSDATE - (30/1440)
GROUP BY username
ORDER BY total_active_samples DESC;

Interpretation

Each sample ‚âà 1 second
on_cpu_samples ‚âà CPU seconds
wait_non_idle_samples ‚âà wait seconds
This is exactly how AAS is calculated


üîÅ AWR Version (Older History)
If ASH retention is short, use AWR:

SELECT
    ash.username AS owner,
    SUM(CASE
            WHEN ash.session_state = 'ON CPU'
            THEN 1
            ELSE 0
        END) AS on_cpu_samples,
    SUM(CASE
            WHEN ash.session_state = 'WAITING'
             AND ash.wait_class <> 'Idle'
            THEN 1
            ELSE 0
        END) AS wait_non_idle_samples,
    COUNT(*) AS total_active_samples
FROM dba_hist_active_sess_history ash
WHERE ash.sample_time BETWEEN
      TO_DATE('&begin_time','YYYY-MM-DD HH24:MI')
  AND TO_DATE('&end_time','YYYY-MM-DD HH24:MI')
GROUP BY ash.username
ORDER BY total_active_samples DESC;

‚ùå Why WAIT IDLE Cannot Be Historical

Idle sessions:
Are not performance-relevant
Can be thousands (connection pools)
Would explode AWR size
So Oracle never stores them historically.
If you see a tool claiming otherwise ‚Üí it is lying or approximating.


DASHBOARD

WITH session_classification AS (
    SELECT
        s.username                            AS owner,
        s.sql_id,
        CASE
            WHEN s.state = 'ON CPU'
                THEN 'ON_CPU'
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
                THEN 'WAIT_NON_IDLE'
            WHEN s.state = 'WAITING'
             AND s.wait_class = 'Idle'
                THEN 'WAIT_IDLE'
            WHEN s.status = 'KILLED'
                THEN 'KILLED'
            ELSE 'OTHER'
        END AS session_type
    FROM v$session s
    WHERE s.type = 'USER'
),
aggregated AS (
    SELECT
        owner,
        session_type,
        COUNT(*) AS cnt
    FROM session_classification
    GROUP BY owner, session_type
),
sql_pressure AS (
    SELECT
        owner,
        sql_id,
        COUNT(*) AS active_sessions
    FROM session_classification
    WHERE session_type IN ('ON_CPU', 'WAIT_NON_IDLE')
      AND sql_id IS NOT NULL
    GROUP BY owner, sql_id
),
critical_sql AS (
    SELECT
        owner,
        sql_id,
        active_sessions,
        ROW_NUMBER() OVER (
            PARTITION BY owner
            ORDER BY active_sessions DESC
        ) AS rn
    FROM sql_pressure
)
SELECT
    a.owner,

    -- Session state counts
    SUM(CASE WHEN a.session_type = 'ON_CPU' THEN a.cnt ELSE 0 END)        AS on_cpu,
    SUM(CASE WHEN a.session_type = 'WAIT_NON_IDLE' THEN a.cnt ELSE 0 END) AS wait_non_idle,
    SUM(CASE WHEN a.session_type = 'WAIT_IDLE' THEN a.cnt ELSE 0 END)     AS wait_idle,
    SUM(CASE WHEN a.session_type = 'KILLED' THEN a.cnt ELSE 0 END)        AS killed,

    -- Total sessions
    SUM(a.cnt) AS total_sessions,

    -- Critical SQL
    c.sql_id               AS critical_sql_id,
    c.active_sessions      AS critical_sql_active_sessions

FROM aggregated a
LEFT JOIN critical_sql c
    ON a.owner = c.owner
   AND c.rn = 1
GROUP BY
    a.owner,
    c.sql_id,
    c.active_sessions
ORDER BY
    (SUM(CASE
        WHEN a.session_type IN ('ON_CPU','WAIT_NON_IDLE')
        THEN a.cnt ELSE 0 END)) DESC;

*************************************************************************

CREATE OR REPLACE VIEW lc_scmt.session_dashboard_v AS
SELECT
    s.username AS owner,

    /* Session state counts */
    SUM(CASE
            WHEN s.status = 'KILLED'
            THEN 1 ELSE 0
        END) AS killed,

    SUM(CASE
            WHEN s.state = 'ON CPU'
            THEN 1 ELSE 0
        END) AS on_cpu,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
            THEN 1 ELSE 0
        END) AS wait_non_idle,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class = 'Idle'
            THEN 1 ELSE 0
        END) AS wait_idle,

    COUNT(*) AS total_sessions,

    /* Critical SQL_ID per owner */
    (
        SELECT sql_id
        FROM (
            SELECT
                s2.sql_id,
                COUNT(*) AS active_cnt
            FROM v$session s2
            WHERE s2.username = s.username
              AND s2.sql_id IS NOT NULL
              AND (
                    s2.state = 'ON CPU'
                 OR (s2.state = 'WAITING' AND s2.wait_class <> 'Idle')
                  )
            GROUP BY s2.sql_id
            ORDER BY active_cnt DESC
        )
        WHERE ROWNUM = 1
    ) AS critical_sql_id,

    /* How many active sessions that SQL has */
    (
        SELECT MAX(active_cnt)
        FROM (
            SELECT
                COUNT(*) AS active_cnt
            FROM v$session s3
            WHERE s3.username = s.username
              AND s3.sql_id IS NOT NULL
              AND (
                    s3.state = 'ON CPU'
                 OR (s3.state = 'WAITING' AND s3.wait_class <> 'Idle')
                  )
            GROUP BY s3.sql_id
        )
    ) AS critical_sql_active_sessions

FROM v$session s
WHERE s.type = 'USER'
GROUP BY s.username;

************************************************

CREATE OR REPLACE VIEW lc_scmt.session_dashboard_v AS
SELECT
    s.username AS owner,

    /* Explicit session categories */
    SUM(CASE
            WHEN s.status = 'KILLED'
            THEN 1 ELSE 0
        END) AS killed,

    SUM(CASE
            WHEN s.state = 'ON CPU'
            THEN 1 ELSE 0
        END) AS on_cpu,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
            THEN 1 ELSE 0
        END) AS wait_non_idle,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class = 'Idle'
            THEN 1 ELSE 0
        END) AS wait_idle,

    /* Everything else (WAITED SHORT TIME, transitions, etc.) */
    SUM(CASE
            WHEN s.state NOT IN ('ON CPU', 'WAITING')
            THEN 1
            ELSE 0
        END) AS other_sessions,

    /* Guaranteed to match sum of all above */
    COUNT(*) AS total_sessions,

    /* Critical SQL_ID */
    (
        SELECT sql_id
        FROM (
            SELECT
                s2.sql_id,
                COUNT(*) AS active_cnt
            FROM v$session s2
            WHERE s2.username = s.username
              AND s2.sql_id IS NOT NULL
              AND (
                    s2.state = 'ON CPU'
                 OR (s2.state = 'WAITING' AND s2.wait_class <> 'Idle')
                  )
            GROUP BY s2.sql_id
            ORDER BY active_cnt DESC
        )
        WHERE ROWNUM = 1
    ) AS critical_sql_id,

    /* Active sessions for that SQL */
    (
        SELECT MAX(active_cnt)
        FROM (
            SELECT
                COUNT(*) AS active_cnt
            FROM v$session s3
            WHERE s3.username = s.username
              AND s3.sql_id IS NOT NULL
              AND (
                    s3.state = 'ON CPU'
                 OR (s3.state = 'WAITING' AND s3.wait_class <> 'Idle')
                  )
            GROUP BY s3.sql_id
        )
    ) AS critical_sql_active_sessions

FROM v$session s
WHERE s.type = 'USER'
GROUP BY s.username;

-----------------------------------------------

CREATE OR REPLACE VIEW lc_scmt.session_dashboard_v AS
SELECT
    s.username AS owner,

    /* Session categories */
    SUM(CASE WHEN s.status = 'KILLED' THEN 1 ELSE 0 END) AS killed,

    SUM(CASE WHEN s.state = 'ON CPU' THEN 1 ELSE 0 END) AS on_cpu,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class <> 'Idle'
            THEN 1 ELSE 0
        END) AS wait_non_idle,

    SUM(CASE
            WHEN s.state = 'WAITING'
             AND s.wait_class = 'Idle'
            THEN 1 ELSE 0
        END) AS wait_idle,

    SUM(CASE
            WHEN s.state NOT IN ('ON CPU', 'WAITING')
            THEN 1 ELSE 0
        END) AS other_sessions,

    COUNT(*) AS total_sessions,

    /* Top 3 critical SQL_IDs */
    (
        SELECT LISTAGG(sql_id || '(' || active_cnt || ')', ', ')
               WITHIN GROUP (ORDER BY active_cnt DESC)
        FROM (
            SELECT *
            FROM (
                SELECT
                    s2.sql_id,
                    COUNT(*) AS active_cnt
                FROM v$session s2
                WHERE s2.username = s.username
                  AND s2.sql_id IS NOT NULL
                  AND (
                        s2.state = 'ON CPU'
                     OR (s2.state = 'WAITING' AND s2.wait_class <> 'Idle')
                      )
                GROUP BY s2.sql_id
                ORDER BY active_cnt DESC
            )
            WHERE ROWNUM <= 3
        )
    ) AS critical_sql_top3

FROM v$session s
WHERE s.type = 'USER'
GROUP BY s.username;

*****************************************************************

CREATE OR REPLACE VIEW lc_scmt.session_dashboard_v AS
SELECT
    owner,

    SUM(CASE WHEN session_class = 'KILLED'        THEN 1 ELSE 0 END) AS killed,
    SUM(CASE WHEN session_class = 'ON_CPU'        THEN 1 ELSE 0 END) AS on_cpu,
    SUM(CASE WHEN session_class = 'WAIT_NON_IDLE' THEN 1 ELSE 0 END) AS wait_non_idle,
    SUM(CASE WHEN session_class = 'WAIT_IDLE'     THEN 1 ELSE 0 END) AS wait_idle,
    SUM(CASE WHEN session_class = 'OTHER'         THEN 1 ELSE 0 END) AS other_sessions,

    COUNT(*) AS total_sessions,

    /* TOP 5 critical SQL with wait class + blocked count */
    (
        SELECT LISTAGG(
                   sql_id || '[' ||
                   active_cnt || '|' ||
                   NVL(wait_class,'CPU') || '|' ||
                   blocked_cnt || ']',
                   ', '
               ) WITHIN GROUP (ORDER BY active_cnt DESC)
        FROM (
            SELECT *
            FROM (
                SELECT
                    s2.sql_id,
                    COUNT(*) AS active_cnt,

                    /* dominant wait class */
                    MAX(wc.wait_class) KEEP (
                        DENSE_RANK FIRST ORDER BY wc.wc_cnt DESC
                    ) AS wait_class,

                    /* blocked sessions */
                    SUM(CASE
                            WHEN s2.blocking_session IS NOT NULL
                            THEN 1 ELSE 0
                        END) AS blocked_cnt
                FROM (
                    SELECT
                        username AS owner,
                        sql_id,
                        blocking_session,
                        CASE
                            WHEN status = 'KILLED'
                                THEN 'KILLED'
                            WHEN state = 'ON CPU'
                                THEN 'ON_CPU'
                            WHEN state = 'WAITING' AND wait_class <> 'Idle'
                                THEN 'WAIT_NON_IDLE'
                            WHEN state = 'WAITING' AND wait_class = 'Idle'
                                THEN 'WAIT_IDLE'
                            ELSE 'OTHER'
                        END AS session_class
                    FROM v$session
                    WHERE type = 'USER'
                ) s2
                LEFT JOIN (
                    SELECT
                        sql_id,
                        wait_class,
                        COUNT(*) wc_cnt
                    FROM v$session
                    WHERE state = 'WAITING'
                      AND wait_class <> 'Idle'
                    GROUP BY sql_id, wait_class
                ) wc
                  ON wc.sql_id = s2.sql_id
                WHERE s2.owner = owner
                  AND s2.sql_id IS NOT NULL
                  AND s2.session_class IN ('ON_CPU','WAIT_NON_IDLE')
                GROUP BY s2.sql_id
                ORDER BY active_cnt DESC
            )
            WHERE ROWNUM <= 5
        )
    ) AS critical_sql_top5

FROM (
    SELECT
        username AS owner,
        CASE
            WHEN status = 'KILLED'
                THEN 'KILLED'
            WHEN state = 'ON CPU'
                THEN 'ON_CPU'
            WHEN state = 'WAITING' AND wait_class <> 'Idle'
                THEN 'WAIT_NON_IDLE'
            WHEN state = 'WAITING' AND wait_class = 'Idle'
                THEN 'WAIT_IDLE'
            ELSE 'OTHER'
        END AS session_class
    FROM v$session
    WHERE type = 'USER'
)
GROUP BY owner;

****************************************************************************

CREATE OR REPLACE VIEW lc_scmt.session_dashboard_v AS
SELECT
    owner,

    /* Mutually exclusive session counts */
    SUM(CASE WHEN session_class = 'KILLED'        THEN 1 ELSE 0 END) AS killed,
    SUM(CASE WHEN session_class = 'ON_CPU'        THEN 1 ELSE 0 END) AS on_cpu,
    SUM(CASE WHEN session_class = 'WAIT_NON_IDLE' THEN 1 ELSE 0 END) AS wait_non_idle,
    SUM(CASE WHEN session_class = 'WAIT_IDLE'     THEN 1 ELSE 0 END) AS wait_idle,
    SUM(CASE WHEN session_class = 'OTHER'         THEN 1 ELSE 0 END) AS other_sessions,

    COUNT(*) AS total_sessions,

    /* TOP 5 critical SQL_IDs with active count, wait class, blocked count */
    (
        SELECT LISTAGG(
                   sql_id || '[' ||
                   active_cnt || '|' ||
                   NVL(
                       CASE
                           WHEN wait_class = 'Other' THEN 'Internal'
                           ELSE wait_class
                       END,
                       'CPU'
                   ) || '|' ||
                   blocked_cnt || ']',
                   ', '
               ) WITHIN GROUP (ORDER BY active_cnt DESC)
        FROM (
            SELECT *
            FROM (
                SELECT
                    s2.sql_id,

                    /* Active pressure */
                    COUNT(*) AS active_cnt,

                    /* Dominant non-idle wait class */
                    MAX(wc.wait_class) KEEP (
                        DENSE_RANK FIRST ORDER BY wc.wc_cnt DESC
                    ) AS wait_class,

                    /* Blocked sessions */
                    SUM(
                        CASE
                            WHEN s2.blocking_session IS NOT NULL
                            THEN 1 ELSE 0
                        END
                    ) AS blocked_cnt

                FROM (
                    SELECT
                        username AS owner,
                        sql_id,
                        blocking_session,
                        CASE
                            WHEN status = 'KILLED'
                                THEN 'KILLED'
                            WHEN state = 'ON CPU'
                                THEN 'ON_CPU'
                            WHEN state = 'WAITING'
                             AND wait_class <> 'Idle'
                                THEN 'WAIT_NON_IDLE'
                            WHEN state = 'WAITING'
                             AND wait_class = 'Idle'
                                THEN 'WAIT_IDLE'
                            ELSE 'OTHER'
                        END AS session_class
                    FROM v$session
                    WHERE type = 'USER'
                ) s2
                LEFT JOIN (
                    SELECT
                        sql_id,
                        wait_class,
                        COUNT(*) AS wc_cnt
                    FROM v$session
                    WHERE state = 'WAITING'
                      AND wait_class <> 'Idle'
                    GROUP BY sql_id, wait_class
                ) wc
                  ON wc.sql_id = s2.sql_id
                WHERE s2.owner = owner
                  AND s2.sql_id IS NOT NULL
                  AND s2.session_class IN ('ON_CPU','WAIT_NON_IDLE')
                GROUP BY s2.sql_id
                ORDER BY active_cnt DESC
            )
            WHERE ROWNUM <= 5
        )
    ) AS critical_sql_top5

FROM (
    SELECT
        username AS owner,
        CASE
            WHEN status = 'KILLED'
                THEN 'KILLED'
            WHEN state = 'ON CPU'
                THEN 'ON_CPU'
            WHEN state = 'WAITING'
             AND wait_class <> 'Idle'
                THEN 'WAIT_NON_IDLE'
            WHEN state = 'WAITING'
             AND wait_class = 'Idle'
                THEN 'WAIT_IDLE'
            ELSE 'O



