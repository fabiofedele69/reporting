1️⃣ Base View You Need

All queries use:

V$SESSION
V$SESSION_WAIT / V$SESSION_EVENT
V$EVENT_NAME

You need SELECT_CATALOG_ROLE or DBA.

2️⃣ Active Sessions (ON CPU)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.status,
    s.sql_id,
    s.program,
    s.machine
FROM v$session s
WHERE s.status = 'ACTIVE'
  AND s.state = 'ON CPU';

Meaning
- Session is executing SQL
- Using CPU
- Counts as Active Session

3️⃣ Waiting – NON-IDLE (Active Wait)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.event,
    s.wait_class,
    s.seconds_in_wait
FROM v$session s
WHERE s.status = 'ACTIVE'
  AND s.state = 'WAITING'
  AND s.wait_class <> 'Idle';

Meaning
- Session is blocked on DB resource
- Still counts as Active Session

4️⃣ Waiting – IDLE (Not Active)
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.event,
    s.wait_class,
    s.seconds_in_wait
FROM v$session s
WHERE s.state = 'WAITING'
  AND s.wait_class = 'Idle';

Meaning
- Connected, doing nothing
- Does NOT count as active workload

5️⃣ Combined View (Most Useful)
This gives you everything in one query with clear classification:

SELECT
    s.sid,
    s.serial#,
    s.username,
    s.sql_id,
    s.state,
    s.wait_class,
    s.event,
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END AS session_type
FROM v$session s
WHERE s.type = 'USER'
ORDER BY session_type, s.sid;

6️⃣ Aggregated View (Perfect for Graphs)
This query is ideal if you want counts per category:

SELECT
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END AS session_type,
    COUNT(*) AS session_count
FROM v$session s
WHERE s.type = 'USER'
GROUP BY
    CASE
        WHEN s.state = 'ON CPU' THEN 'ON_CPU'
        WHEN s.state = 'WAITING' AND s.wait_class <> 'Idle' THEN 'WAIT_NON_IDLE'
        WHEN s.state = 'WAITING' AND s.wait_class = 'Idle' THEN 'WAIT_IDLE'
    END;

7️⃣ Historical Version (ASH – Last 10 Minutes)
If you want historical SQL_IDs (not just current):

SELECT
    sql_id,
    session_state,
    wait_class,
    COUNT(*) samples
FROM v$active_session_history
WHERE sample_time > SYSDATE - (10/1440)
GROUP BY sql_id, session_state, wait_class
ORDER BY samples DESC;

Interpretation
- SESSION_STATE = 'ON CPU'
- SESSION_STATE = 'WAITING'
- WAIT_CLASS = 'Idle' → idle

8️⃣ Blocking Sessions (Bonus)
SELECT
    s.sid,
    s.serial#,
    s.sql_id,
    s.blocking_session,
    s.event,
    s.wait_class
FROM v$session s
WHERE s.blocking_session IS NOT NULL;

9️⃣ DBA Golden Rule (Remember This)
Performance analysis = ON CPU + WAIT NON-IDLE
WAIT IDLE = ignore for tuning

How to Get the SQL Statement from a SQL_ID (Oracle 19c)
From Memory (Best / Real-Time)
Use V$SQL (SQL still in shared pool)

SELECT
    sql_id,
    child_number,
    sql_text
FROM v$sql
WHERE sql_id = '<SQL_ID>';

Notes
- Returns current SQL text
- Multiple rows = multiple child cursors
- Fastest and most accurate
⚠️ If no rows → SQL aged out of memory

Full SQL Text (Long Statements)
V$SQL.SQL_TEXT is truncated.
To get the complete SQL:

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_fulltext, 4000, 1) AS sql_text
FROM v$sql
WHERE sql_id = '<SQL_ID>';

For >4000 chars, extract in chunks.

From Active Sessions (If Still Running)
SELECT
    s.sid,
    s.serial#,
    s.sql_id,
    q.sql_text
FROM v$session s
JOIN v$sql q ON s.sql_id = q.sql_id
WHERE s.sql_id = '<SQL_ID>';

From AWR (Historical – Most Reliable)
Use DBA_HIST_SQLTEXT

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_text, 4000, 1) AS sql_text
FROM dba_hist_sqltext
WHERE sql_id = '<SQL_ID>';

Notes
- Requires Diagnostics Pack
- SQL must have appeared in AWR snapshot
- Works even if SQL aged out of memory

From ASH (Correlating to Execution Time)
SELECT DISTINCT
    ash.sql_id,
    DBMS_LOB.SUBSTR(txt.sql_text, 4000, 1) AS sql_text
FROM v$active_session_history ash
JOIN dba_hist_sqltext txt ON ash.sql_id = txt.sql_id
WHERE ash.sql_id = '<SQL_ID>';

Using TOAD (GUI Way – Quick)
If you are in TOAD:
Paste SQL_ID
Open:
Database → Monitor → Sessions
Right-click session → View SQL
Or:
Database → Diagnose → AWR → Top SQL
→ Double-click SQL_ID
TOAD internally queries V$SQL or DBA_HIST_SQLTEXT.

Edge Cases You Should Know
SQL_ID Exists but No SQL Text

Possible reasons:
SQL aged out of shared pool
SQL not captured in AWR
Privilege issue
Multiple SQL Texts for Same SQL_ID?

❌ Impossible
SQL_ID is a hash of SQL text.

One-Query “Try Everything” (Recommended)
SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_fulltext, 4000, 1) AS sql_text,
    'V$SQL' AS source
FROM v$sql
WHERE sql_id = '<SQL_ID>'

UNION ALL

SELECT
    sql_id,
    DBMS_LOB.SUBSTR(sql_text, 4000, 1),
    'AWR'
FROM dba_hist_sqltext
WHERE sql_id = '<SQL_ID>';

DBA Rule to Remember
If the SQL is still running → V$SQL
If it ran in the past → AWR
